## 1. 배열 정의
- 배열은 **동일한 자료형**을 묶어 저장하는 참조 자료형이다.
- 생성할 때 크기를 지정해야 하고, 한 번 크기를 지정하면 절대 **크기를 변경할 수 없다.**
* 크기란 배열의 길이이고, 이는 배열에 저장할 수 있는 데이터의 수를 의미한다.

## 2. 배열 생성

    1) 배열 선언
    2) 힙 메모리에 배열 객체 생성
    3) 배열 자료형 변수에 객체 대입
    4) 객체에 값 입력

### 1 ) 배열 선언
배열은 2가지 방법으로 선언할 수 있다.

	1) 자료형[] 변수명;
	2) 자료형 변수명[];

#### ex) 예시

	1) int[] arr;
	2) int arr[];

배열 선언 시, **자료형[]** 형식으로 배열의 자료형을 선언하는 것을 통해, **배열은 동일한 자료형만 저장할 수 있다**는 특징을 확인할 수 있다.

배열을 선언하면 스택 메모리에 변수의 공간만 생성하고, 공간 안은 비워둔다.
아직 배열의 실제 데이터인 객체를 생성하지 않았기 때문이다.
스택 메모리에 위치하고 있는 참조 자료형 변수의 빈 공간을 초기화할 때는 null값을 사용할 수 있다.
**null 값은 힙 메모리의 위치를 가리키고 있지 않다는 의미다.**
즉, 연결된 실제 데이터가 없다는 것을 의미한다.

||클래스:정적:상수:메서드 영역|**스택 영역**|힙 영역|
|-|:-:|:-:|:-:|
|int[] a;| |**[ ]**||
|||a||
|||||
|int[] a = null;| |**[null]**||
|||a||


> ### 자바의 메모리 구조
> **자바의 메모리 구조는 3개의 영역**으로 구성돼 있다.
> 
> |첫 번째 영역|두 번째 영역|세 번째 영역|
> |:-:|:-:|:-:|
> |클래스 영역|**스택 영역**|힙 영역|
> |정적 영역|(모든 지역 변수)|(실제 데이터)|
> |상수 영역||(객체)|
> |메서드 영역|||
> 
> 첫 번째 영역에 클래스와 메서드가 위치하고 있으며, **스택 영역은** 기본 자료형이든, 참조 자료형이든 상관없이 **모든 지역 변수**가 위치하는 영역이다. 마지막으로 **힙 영역은 객체가 위치**하는 공간이며, 객체는 참조 자료형 변수가 가리키는 실제 데이터라고 생각하면 된다.
>

### 2 ) 힙 메모리에 배열 객체 생성

모든 참조 자료형의 실제 데이터(객체)는 힙 메모리에 생성된다.
힙 메모리에 객체를 생성하기 위해서는 new 키워드를 사용해야 한다.

    new 자료형[배열의 길이]
#### ex) 예시

	new int[3]
	new String[5]
    new int[]       // 객체의 크기를 지정하지 않아 오류 발생

배열 생성 과정에서, 배열을 생성할 때 반드시 배열의 길이를 지정해야 한다는 특징을 알 수 있다. 배열의 길이를 저장하지 않고 new int[]와 같이 명령하면 객체의 크기를 지정하지 않아 오류가 발생한다.

### 3 ) 배열 자료형 변수에 객체 대입

선언된 배열 참조 자료형 변수에 생성한 객체를 대입하는 데는 2가지 방법이 있는데, 변수 선언과 값의 대입을 한 번에 작성해도 되고, 따로 구분해 작성해도 된다.

    자료형[] 변수명 = new 자료형[배열의 길이];

    자료형[] 변수명;
    변수명 = new 자료형[배열의 길이];

#### ex) 예시

	int[] arr = new int[3];

	int[] arr;
    arr = new int[5];

예시 코드의 arr은 참조 변수로, 실제 데이터값을 저장하는 것이 아니라 실제 데이터값의 위칫값을 저장한다. new 키워드는 힙 메모리에 객체를 넣으라는 의미이고, intp[3]은 정수 3개를 저장할 수 있는 공간을 만들라는 의미이다. 따라서 'int[] arr = new int[3];' 은 'int 자료형 3개를 저장할 수 있는 공간을 힙 메모리에 넣고, 어디에 넣었는지를 참조 변수 arr에 저장하라'는 의미이다.

스택 메모리 공간은 값을 초기화하지 않으면 빈 공간으로 존재한다. 이때 해당 변수를 출력하면 오류가 발생한다. 반면 힙 메모리는 어떤 상황에서도 빈 공간이 존재하지 않는다. 그래서 값을 주지 않으면 컴파일러가 값을 강제로 초기화한다. 강제 초기화 값은 자료형에 따라 다른데, 기본 자료형일 때 숫자는 모두 0 (실수는 0.0), 불리언은 false로 값이 초기화되고, 이외의 모든 참조 자료형은 null로 초기화된다.

> ### 객체의 위치를 참조 변수에 저장하는 이유
> new 키워드를 이용해 객체를 생성하면 자바 가상 머신은 힙 메모리 내에 비어 있는 공간에 객체를 생성한다. 힙 메모리에 비어 있는 공간은 그때그때 다를 것이므로 객체가 생성될 때마다 다른 위치에 저장될 수 있다. 따라서 자바 가상 머신이 생성한 객체의 위치를 반드시 알아야 개발자가 해당 객체를 사용할 수 있다. 

### 4 ) 객체에 값 입력

생성한 객체에 값을 입력하는 방법을 알아보자. 배열은 값을 저장할 수 있는 공간마다 번호를 가지는데 이를 인덱스 index 라고 한다. 인덱스는 0부터 시작하며, 1씩 증가한다.

    변수명[인덱스] = 값;

#### ex) 예시

	int[] arr = new int[3];

	arr[0] = 1;
	arr[1] = 2;
	arr[2] = 3;

## 3. 1차원 배열을 생성하는 다양한 방법

## 4. 참조 변수와 배열 객체의 값 초기화하기

스택 메모리 변수를 초기화하지 않으면 메모리 공간은 텅 비어 있고, 이 상태에서 해당 변수를 출력하면 오류가 발생한다. 기본 자료형 변수이든, 참조 자료형 변수이든 모든 변수는 스택 메모리에 위치하고 있다. 따라서 모든 변수는 초기화 이후에만 출력할 수 있다.


#### 초기화하지 않을 때의 초깃값
    int a;                  // 기본 자료형 변수 선언; 초기화 X
    int[] b;                // 참조 자료형 변수 선언; 초기화 X
    System.out.println(a);  // 오류 발생
    System.out.println(b);  // 오류 발생

기본 자료형 변수는 스택에 실제 데이터값을 저장하므로 초깃값 역시 실제 데이터값을 저장한다. 반면 참조 자료형 변수는 실제 데이터의 위치를 저장하므로 초깃값으로는 실제 데이ㅓ값이 아닌 '가리키고 있는 위치가 없음'을 나타내는 null을 사용한다. 정리하면 기본 자료형의 초깃값으로는 '값', 참조 자료형의 초깃값으로는 'null'을 사용하면 된다.

#### 기본 자료형과 참조 자료형의 초깃값
    int a = ;               // 기본 자료형 변수 선언; 0으로 초기화
    int[] b = null;         // 참조 자료형 변수 선언; null로 초기화
    System.out.println(a);  // 0 출력
    System.out.println(b);  // null 출력


> ### 힙 메모리에서의 강제 초깃값
> 힙 메모리는 모든 공간에 값이 들어가 있어야 하며 초기화를 하지 않았을 때 자바 가상 머신이 강제 초기화한다. 강제 초기화될 때의 기본값은 다음과 같다.
>|기본/참조|자료형|기본값|
>|:-:|:-|:-:|
>|기본|boolean|false|
>|기본|정수 (byte, short, int, long)|0|
>|기본|실수 (float, double)|0.0|
>|참조|클래스, 배열 ...|null|

## 5. 참조 자료형으로서 배열의 특징

기본 자료형과 참조 자료형의 차이를 더 알아보기 위해 기본 자료형과 참조 자료형에서 변수를 복사할 때를 비교해보자.

먼저 **대입 연산자(=)** 를 이용해 변수가 복사되는 과정을 이해해야 한다. 대입 연산자를 이용한 변수의 복사에서 **복사 대상**은 바로 변수에 포함돼 있는 **스택 메모리의 값**이다. 그런데 기본 자료형과 참조 자료형이 스택 메모리에 저장하는 값의 의미가 다르므로 자연스럽게 둘 사이에 차이가 발생하는 것이다.

    int a = 3;
    int b = a;
    b = 7;

    System.out.println(a);  // 3
    System.out.println(b);  // 7

**기본 자료형**은 스택 메모리에 **실제 데이터값**을 저장하고 있으므로 기본 자료형 변수를 복사하면 실제 데이터값이 1개 더 복사된다. 이후 <u>복사된 값을 아무리 변경해도 원본 값은 아무런 영향을 받지 않는다.</u>

그러나 **참조 자료형**은 스택 메모리에 실제 데이터 값이 아닌 **힙 메모리에 저장된 객체의 위치**를 저장하고 있기 때문에, 참조 자료형 변수를 복사하면 실제 데이터의 위칫값이 복사되므로, <u>복사한 참조 변수를 이용해 데이터를 수정하면 다른 참조 변수가 가리키는 데이터도 변하게 되는 것이다.</u>

    int[] a = {3, 4, 5};
    int[] b = a;        // 힙 메모리에 저장된 객체의 위치를 복사
    b[] = 7;

    System.out.println(a[0]);  // 7
    System.out.println(b[0]);  // 7

> **(책 포함 내용 X)**
>
> [출처](https://kyhyuk.tistory.com/182)
>
> #### Call By Value 
> - 값을 호출
> - 전달 받은 값을 복사하여 처리
> #### Call By Reference
> - 참조에 의한 호출
> - 전달받은 값을 직접 참조
> 
> #### 깊은 복사 (Deep Copy)
> - 새로운 메모리 공간에 값(Value)을 복사
> - **특정 객체를 깊은 복사하는 경우 Clonable 인터페이스의 clone() 메서드를 Overridng 하여 깊은 복사를 할 수 있다.**
>
> #### 얕은 복사 (Shallow Copy)
> - 주소값이 복사

## 6. 반복문을 이용해 배열 데이터 읽기
## 7. 2차원 정방 행렬 배열
## 8. 2차원 비정방 행렬 배열
## 9. 2차원 배열의 출력
## 10. main() 메서드의 입력 매개변수
